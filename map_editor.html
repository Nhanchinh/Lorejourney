<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LibGDX Map Editor - T·∫°o Map M·ªõi</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background: #2c3e50;
            color: white;
            overflow-x: auto;
        }
        
        .container {
            display: flex;
            gap: 20px;
            min-height: 100vh;
        }
        
        .sidebar {
            width: 300px;
            background: #34495e;
            padding: 20px;
            border-radius: 10px;
            height: fit-content;
            position: sticky;
            top: 10px;
        }
        
        .main-content {
            flex: 1;
            background: #34495e;
            padding: 20px;
            border-radius: 10px;
        }
        
        h1, h2, h3 {
            color: #ecf0f1;
            margin-top: 0;
        }
        
        .section {
            background: #2c3e50;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        
        .input-group {
            margin-bottom: 10px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .input-group input, .input-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid #3498db;
            border-radius: 5px;
            background: #ecf0f1;
            color: #2c3e50;
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        button.active {
            background: #e74c3c;
        }
        
        .tile-palette {
            background: #2c3e50;
            border: 2px solid #3498db;
            border-radius: 5px;
            padding: 10px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .tile-grid {
            display: grid;
            grid-template-columns: repeat(16, 32px);
            gap: 2px;
            justify-content: center;
        }
        
        .tile-item {
            width: 32px;
            height: 32px;
            border: 2px solid transparent;
            cursor: pointer;
            image-rendering: pixelated;
            background: #34495e;
        }
        
        .tile-item:hover {
            border-color: #f39c12;
        }
        
        .tile-item.selected {
            border-color: #e74c3c;
            border-width: 3px;
        }
        
        .map-canvas {
            border: 2px solid #3498db;
            background: #ecf0f1;
            cursor: crosshair;
            image-rendering: pixelated;
        }
        
        .layer-tabs {
            display: flex;
            margin-bottom: 10px;
        }
        
        .layer-tab {
            padding: 10px 20px;
            background: #95a5a6;
            color: white;
            border: none;
            cursor: pointer;
            margin-right: 5px;
        }
        
        .layer-tab.active {
            background: #3498db;
        }
        
        .tools {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .tool {
            padding: 8px 12px;
            background: #95a5a6;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .tool.active {
            background: #e74c3c;
        }
        
        .export-area {
            background: #2c3e50;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
        
        .export-text {
            width: 100%;
            height: 200px;
            background: #ecf0f1;
            color: #2c3e50;
            border: 2px solid #3498db;
            border-radius: 5px;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
        }
        
        .info {
            background: #27ae60;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .special-tiles {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .special-tile {
            padding: 10px;
            background: #95a5a6;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            font-size: 12px;
        }
        
        .special-tile.selected {
            background: #e74c3c;
        }
        
        .coordinates {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="coordinates" id="coordinates">X: 1, Y: 1</div>
    
    <div class="container">
        <div class="sidebar">
            <h2>üéÆ Map Editor</h2>
            
            <div class="section">
                <h3>Map Settings</h3>
                <div class="input-group">
                    <label>Width:</label>
                    <input type="number" id="mapWidth" value="15" min="5" max="50">
                </div>
                <div class="input-group">
                    <label>Height:</label>
                    <input type="number" id="mapHeight" value="13" min="5" max="50">
                </div>
                <div class="input-group">
                    <label>Player Spawn X:</label>
                    <input type="number" id="playerX" value="7" min="0">
                </div>
                <div class="input-group">
                    <label>Player Spawn Y:</label>
                    <input type="number" id="playerY" value="4" min="0">
                </div>
                <div class="input-group">
                    <label>Dark Map:</label>
                    <select id="isDark" disabled>
                        <option value="0">No (Kh√¥ng d√πng trong format m·ªõi)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Weather:</label>
                    <select id="weather" disabled>
                        <option value="0">Normal (Kh√¥ng d√πng trong format m·ªõi)</option>
                    </select>
                </div>
                <button onclick="createNewMap()">Create New Map</button>
            </div>
            
            <div class="section">
                <h3>Tools</h3>
                <div class="tools">
                    <button class="tool active" id="paintTool" onclick="setTool('paint')">üñåÔ∏è Paint</button>
                    <button class="tool" id="eraseTool" onclick="setTool('erase')">üßΩ Erase</button>
                    <button class="tool" id="fillTool" onclick="setTool('fill')">ü™£ Fill</button>
                </div>
            </div>
            
            <div class="section">
                <h3>Tile Palette</h3>
                <p>Selected Tile ID: <span id="selectedTileId">Empty (0)</span></p>
                <div class="info" style="background: #f39c12; font-size: 12px; margin-bottom: 10px;">
                    <strong>‚ö†Ô∏è L∆ØU √ù:</strong> Tile ID b·∫Øt ƒë·∫ßu t·ª´ 1<br>
                    ID 0 = tile tr·ªëng, ID 1 = tile ƒë·∫ßu ti√™n trong sprite sheet
                </div>
                <div class="tile-palette">
                    <canvas id="tilePalette" class="tile-grid"></canvas>
                </div>
                
                <h4>Special Tiles</h4>
                <div class="special-tiles">
                    <div class="special-tile" onclick="selectSpecialTile('question')" id="specialQuestion">
                        üîë KEY<br>ID: 10
                    </div>
                    <div class="special-tile" onclick="selectSpecialTile('teleport')" id="specialTeleport">
                        üîò BUTTON<br>ID: 11
                    </div>
                    <div class="special-tile" onclick="selectSpecialTile('exclamation')" id="specialExclamation">
                        üö™ DOOR<br>ID: 12
                    </div>
                    <div class="special-tile" onclick="selectSpecialTile('end')" id="specialEnd">
                        üèÅ END<br>ID: 14
                    </div>
                </div>
            </div>
            
            <div class="section">
                <button onclick="loadTextureFile()">Load Custom Texture</button>
                <input type="file" id="textureFile" accept="image/*" style="display: none;">
            </div>
        </div>
        
        <div class="main-content">
            <h2>Map Canvas</h2>
            
            <div class="layer-tabs">
                <button class="layer-tab active" onclick="setLayer('bottom')" id="bottomTab">Bottom Layer</button>
                <button class="layer-tab" onclick="setLayer('main')" id="mainTab">Main Layer</button>
                <button class="layer-tab" onclick="setLayer('active')" id="activeTab">Active Layer</button>
            </div>
            
            <div class="tools">
                <button onclick="clearLayer()">Clear Current Layer</button>
                <button onclick="fillLayer()">Fill Current Layer</button>
                <button onclick="loadTemplateFile()">Copy from Template</button>
                <input type="file" id="templateFile" accept=".txt" style="display: none;">
                <label>
                    <input type="checkbox" id="showGrid" checked> Show Grid
                </label>
                <label>
                    <input type="checkbox" id="showPlayerSpawn" checked> Show Player Spawn
                </label>
            </div>
            
            <canvas id="mapCanvas" class="map-canvas"></canvas>
            
            <div class="export-area">
                <h3>Export Map</h3>
                <div class="info" style="background: #e67e22; font-size: 12px; margin-bottom: 15px;">
                    <strong>üìù FORMAT GAME:</strong><br>
                    ‚Ä¢ D√≤ng 1: Chi·ªÅu r·ªông map (width)<br>
                    ‚Ä¢ D√≤ng 2: Chi·ªÅu cao map (height)<br>
                    ‚Ä¢ D√≤ng 3: V·ªã tr√≠ X c·ªßa player spawn (0-based, t·ª´ tr√°i sang ph·∫£i)<br>
                    ‚Ä¢ D√≤ng 4: V·ªã tr√≠ Y c·ªßa player spawn (0-based, t·ª´ tr√™n xu·ªëng d∆∞·ªõi)<br>
                    ‚Ä¢ Ti·∫øp theo: Bottom Layer (background) - 13 d√≤ng<br>
                    ‚Ä¢ Ti·∫øp theo: Main Layer (static tiles + special items) - 13 d√≤ng<br>
                    ‚Ä¢ Cu·ªëi c√πng: Active Layer (moveable/interactive objects) - 13 d√≤ng<br>
                    ‚Ä¢ Special tiles: 10=KEY, 11=BUTTON, 12=DOOR, 14=END<br>
                    ‚Ä¢ C√≥ th·ªÉ load t·ª´ file .txt ƒë·ªÉ copy template
                </div>
                <button onclick="exportMap()">Generate Map Data</button>
                <button onclick="copyToClipboard()">Copy to Clipboard</button>
                <button onclick="downloadMap()">Download as .txt</button>
                <textarea class="export-text" id="exportText" placeholder="Generated map data will appear here..."></textarea>
            </div>
        </div>
    </div>

    <script>
        let textureAtlas = null;
        let currentTool = 'paint';
        let currentLayer = 'bottom';
        let selectedTileId = 0;
        let selectedSpecialTile = null;
        let isMouseDown = false;
        
        // Map data
        let mapData = {
            width: 15,
            height: 13,
            playerSpawn: { x: 7, y: 4 }, // Changed from 8,5 to 7,4 (0-based)
            isDark: 0,
            weather: 0,
            bottomLayer: [],
            mainLayer: [],
            activeLayer: []
        };
        
        const tileSize = 16;
        const canvasTileSize = 32;
        
        // Th√¥ng tin t·ª´ textures.atlas (s·∫Ω ƒë∆∞·ª£c load ƒë·ªông)
        let tilesAtlasInfo = {
            x: 0,
            y: 0,
            width: 256,
            height: 272,
            tileSize: 16,
            tilesPerRow: 16,
            tilesPerCol: 17
        };
        
        // Initialize
        window.addEventListener('load', function() {
            loadAtlasInfo();
        });
        
        function loadAtlasInfo() {
            // Load atlas file to get correct positions
            fetch('android/assets/textures.atlas')
                .then(response => response.text())
                .then(atlasContent => {
                    parseAtlasInfo(atlasContent);
                    loadDefaultTexture();
                    createNewMap();
                    setupEventListeners();
                })
                .catch(error => {
                    console.error('Could not load atlas file:', error);
                    // Use default values and continue
                    loadDefaultTexture();
                    createNewMap();
                    setupEventListeners();
                });
        }
        
        function parseAtlasInfo(atlasContent) {
            const lines = atlasContent.split('\n');
            let foundTiles = false;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === '16x16_tiles') {
                    foundTiles = true;
                    continue;
                }
                
                if (foundTiles && line.startsWith('xy:')) {
                    const coords = line.replace('xy:', '').trim().split(',');
                    tilesAtlasInfo.x = parseInt(coords[0].trim());
                    tilesAtlasInfo.y = parseInt(coords[1].trim());
                } else if (foundTiles && line.startsWith('size:')) {
                    const size = line.replace('size:', '').trim().split(',');
                    tilesAtlasInfo.width = parseInt(size[0].trim());
                    tilesAtlasInfo.height = parseInt(size[1].trim());
                    tilesAtlasInfo.tilesPerRow = Math.floor(tilesAtlasInfo.width / tilesAtlasInfo.tileSize);
                    tilesAtlasInfo.tilesPerCol = Math.floor(tilesAtlasInfo.height / tilesAtlasInfo.tileSize);
                    break; // We have all info we need
                }
            }
            
            console.log('Loaded atlas info:', tilesAtlasInfo);
        }
        
        function loadDefaultTexture() {
            const img = new Image();
            img.onload = function() {
                textureAtlas = img;
                createTilePalette();
            };
            img.onerror = function() {
                console.log('Could not load default texture, will use fallback');
                createFallbackPalette();
            };
            img.src = 'app/src/main/res/drawable/map17x16.png';
        }
        
        function loadTextureFile() {
            document.getElementById('textureFile').click();
        }
        
        function loadTemplateFile() {
            document.getElementById('templateFile').click();
        }
        
        document.getElementById('textureFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    textureAtlas = img;
                    createTilePalette();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
        
        document.getElementById('templateFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                copyFromTemplateFile(e.target.result);
            };
            reader.readAsText(file);
        });
        
        function createTilePalette() {
            const canvas = document.getElementById('tilePalette');
            const ctx = canvas.getContext('2d');
            
            const tilesPerRow = 16;
            const maxTiles = 272; // 17 rows * 16 tiles
            
            canvas.width = tilesPerRow * 34;
            canvas.height = Math.ceil(maxTiles / tilesPerRow) * 34;
            
            ctx.imageSmoothingEnabled = false;
            
            for (let i = 0; i < maxTiles; i++) {
                const row = Math.floor(i / tilesPerRow);
                const col = i % tilesPerRow;
                const x = col * 34;
                const y = row * 34;
                
                // Draw tile background
                ctx.fillStyle = i === 0 ? '#e74c3c' : '#95a5a6';
                ctx.fillRect(x, y, 32, 32);
                
                if (textureAtlas && i > 0) {
                    const tileInfo = getTileFromAtlas(i);
                    if (tileInfo) {
                        ctx.drawImage(
                            textureAtlas,
                            tileInfo.x, tileInfo.y, tileInfo.width, tileInfo.height,
                            x, y, 32, 32
                        );
                    }
                }
                
                // Draw tile number (b·∫Øt ƒë·∫ßu t·ª´ 0, nh∆∞ng 0 = empty)
                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(i === 0 ? 'Empty' : i, x + 16, y + 30);
                
                // Selection border
                if (i === selectedTileId) {
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x, y, 32, 32);
                }
            }
        }
        
        function createFallbackPalette() {
            const canvas = document.getElementById('tilePalette');
            const ctx = canvas.getContext('2d');
            
            const tilesPerRow = 16;
            const maxTiles = 272;
            
            canvas.width = tilesPerRow * 34;
            canvas.height = Math.ceil(maxTiles / tilesPerRow) * 34;
            
            for (let i = 0; i < maxTiles; i++) {
                const row = Math.floor(i / tilesPerRow);
                const col = i % tilesPerRow;
                const x = col * 34;
                const y = row * 34;
                
                // Generate color based on tile ID
                const hue = (i * 137.508) % 360;
                ctx.fillStyle = i === 0 ? '#34495e' : `hsl(${hue}, 50%, 50%)`;
                ctx.fillRect(x, y, 32, 32);
                
                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(i === 0 ? 'Empty' : i, x + 16, y + 16);
                
                if (i === selectedTileId) {
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x, y, 32, 32);
                }
            }
        }
        
        function getTileFromAtlas(tileId) {
            if (!textureAtlas || tileId <= 0) return null;
            
            // Tile ID b·∫Øt ƒë·∫ßu t·ª´ 1, n√™n tr·ª´ 1 ƒë·ªÉ get index
            const index = tileId - 1;
            const row = Math.floor(index / tilesAtlasInfo.tilesPerRow);
            const col = index % tilesAtlasInfo.tilesPerRow;
            
            return {
                x: tilesAtlasInfo.x + (col * tilesAtlasInfo.tileSize),
                y: tilesAtlasInfo.y + (row * tilesAtlasInfo.tileSize),
                width: tilesAtlasInfo.tileSize,
                height: tilesAtlasInfo.tileSize
            };
        }
        
        function setupEventListeners() {
            const canvas = document.getElementById('mapCanvas');
            const palette = document.getElementById('tilePalette');
            
            // Map canvas events
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('mouseleave', handleCanvasMouseUp);
            
            // Tile palette events
            palette.addEventListener('click', handlePaletteClick);
            
            // Input events
            document.getElementById('showGrid').addEventListener('change', renderMap);
            document.getElementById('showPlayerSpawn').addEventListener('change', renderMap);
        }
        
        function handleCanvasMouseDown(e) {
            isMouseDown = true;
            handleCanvasPaint(e);
        }
        
        function handleCanvasMouseMove(e) {
            updateCoordinates(e);
            if (isMouseDown) {
                handleCanvasPaint(e);
            }
        }
        
        function handleCanvasMouseUp() {
            isMouseDown = false;
        }
        
        function updateCoordinates(e) {
            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / canvasTileSize);
            const y = Math.floor((e.clientY - rect.top) / canvasTileSize);
            
            // Display coordinates as 0-based (changed from 1-based)
            document.getElementById('coordinates').textContent = `X: ${x}, Y: ${y}`;
        }
        
        function handleCanvasPaint(e) {
            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / canvasTileSize);
            const y = Math.floor((e.clientY - rect.top) / canvasTileSize);
            
            if (x < 0 || x >= mapData.width || y < 0 || y >= mapData.height) return;
            
            if (currentTool === 'paint') {
                paintTile(x, y);
            } else if (currentTool === 'erase') {
                eraseTile(x, y);
            } else if (currentTool === 'fill') {
                fillArea(x, y);
            }
            
            renderMap();
        }
        
        function handlePaletteClick(e) {
            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / 34);
            const y = Math.floor((e.clientY - rect.top) / 34);
            
            const tileId = y * 16 + x;
            selectedTileId = tileId;
            selectedSpecialTile = null;
            
            // Update UI
            document.getElementById('selectedTileId').textContent = tileId === 0 ? 'Empty (0)' : tileId;
            document.querySelectorAll('.special-tile').forEach(el => el.classList.remove('selected'));
            
            createTilePalette();
        }
        
        function paintTile(x, y) {
            const layer = getCurrentLayer();
            if (selectedSpecialTile) {
                if (currentLayer === 'main') {
                    layer[y][x] = { type: 'animated', value: selectedSpecialTile };
                }
            } else {
                if (currentLayer === 'main') {
                    layer[y][x] = { type: 'tile', id: selectedTileId };
                } else {
                    layer[y][x] = selectedTileId;
                }
            }
        }
        
        function eraseTile(x, y) {
            const layer = getCurrentLayer();
            if (currentLayer === 'main') {
                layer[y][x] = { type: 'tile', id: 0 };
            } else {
                layer[y][x] = 0;
            }
        }
        
        function fillArea(x, y) {
            const layer = getCurrentLayer();
            const targetValue = layer[y][x];
            const newValue = selectedSpecialTile ? 
                { type: 'animated', value: selectedSpecialTile } : 
                (currentLayer === 'main' ? { type: 'tile', id: selectedTileId } : selectedTileId);
            
            floodFill(layer, x, y, targetValue, newValue, new Set());
        }
        
        function floodFill(layer, x, y, targetValue, newValue, visited) {
            if (x < 0 || x >= mapData.width || y < 0 || y >= mapData.height) return;
            
            const key = `${x},${y}`;
            if (visited.has(key)) return;
            visited.add(key);
            
            const currentValue = layer[y][x];
            if (!valuesEqual(currentValue, targetValue)) return;
            
            layer[y][x] = newValue;
            
            floodFill(layer, x + 1, y, targetValue, newValue, visited);
            floodFill(layer, x - 1, y, targetValue, newValue, visited);
            floodFill(layer, x, y + 1, targetValue, newValue, visited);
            floodFill(layer, x, y - 1, targetValue, newValue, visited);
        }
        
        function valuesEqual(a, b) {
            if (typeof a === 'object' && typeof b === 'object') {
                return JSON.stringify(a) === JSON.stringify(b);
            }
            return a === b;
        }
        
        function getCurrentLayer() {
            switch (currentLayer) {
                case 'bottom': return mapData.bottomLayer;
                case 'main': return mapData.mainLayer;
                case 'active': return mapData.activeLayer;
                default: return mapData.bottomLayer;
            }
        }
        
        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool').forEach(el => el.classList.remove('active'));
            document.getElementById(tool + 'Tool').classList.add('active');
        }
        
        function setLayer(layer) {
            currentLayer = layer;
            document.querySelectorAll('.layer-tab').forEach(el => el.classList.remove('active'));
            document.getElementById(layer + 'Tab').classList.add('active');
            renderMap();
        }
        
        function selectSpecialTile(type) {
            const specialTiles = {
                'question': 'a10|4|8',    // KEY -> ID 10
                'teleport': 'a11|4|8',    // BUTTON -> ID 11  
                'exclamation': 'a12|4|8', // DOOR -> ID 12
                'end': 'a14|4|8'          // END -> ID 14
            };
            
            const tileNames = {
                'question': 'KEY (10)',
                'teleport': 'BUTTON (11)',
                'exclamation': 'DOOR (12)',
                'end': 'END (14)'
            };
            
            selectedSpecialTile = specialTiles[type];
            selectedTileId = 0;
            
            document.getElementById('selectedTileId').textContent = tileNames[type];
            document.querySelectorAll('.special-tile').forEach(el => el.classList.remove('selected'));
            document.getElementById('special' + type.charAt(0).toUpperCase() + type.slice(1)).classList.add('selected');
            
            createTilePalette();
        }
        
        function createNewMap() {
            const width = parseInt(document.getElementById('mapWidth').value);
            const height = parseInt(document.getElementById('mapHeight').value);
            
            mapData.width = width;
            mapData.height = height;
            mapData.playerSpawn.x = parseInt(document.getElementById('playerX').value);
            mapData.playerSpawn.y = parseInt(document.getElementById('playerY').value);
            mapData.isDark = parseInt(document.getElementById('isDark').value);
            mapData.weather = parseInt(document.getElementById('weather').value);
            
            // Initialize layers
            mapData.bottomLayer = Array(height).fill().map(() => Array(width).fill(0));
            mapData.mainLayer = Array(height).fill().map(() => Array(width).fill({ type: 'tile', id: 0 }));
            mapData.activeLayer = Array(height).fill().map(() => Array(width).fill(0));
            
            setupMapCanvas();
            renderMap();
        }
        
        function setupMapCanvas() {
            const canvas = document.getElementById('mapCanvas');
            canvas.width = mapData.width * canvasTileSize;
            canvas.height = mapData.height * canvasTileSize;
        }
        
        function renderMap() {
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const showGrid = document.getElementById('showGrid').checked;
            const showPlayerSpawn = document.getElementById('showPlayerSpawn').checked;
            
            // Render layers
            for (let y = 0; y < mapData.height; y++) {
                for (let x = 0; x < mapData.width; x++) {
                    const canvasX = x * canvasTileSize;
                    const canvasY = y * canvasTileSize;
                    
                    // Bottom layer (always visible as base)
                    if (mapData.bottomLayer[y][x] > 0) {
                        renderTile(ctx, mapData.bottomLayer[y][x], canvasX, canvasY, 0.3);
                    }
                    
                    // Current layer
                    let currentValue;
                    switch (currentLayer) {
                        case 'bottom':
                            currentValue = mapData.bottomLayer[y][x];
                            break;
                        case 'main':
                            currentValue = mapData.mainLayer[y][x];
                            break;
                        case 'active':
                            currentValue = mapData.activeLayer[y][x];
                            break;
                    }
                    
                    if (currentLayer === 'main' && currentValue.type) {
                        if (currentValue.type === 'tile' && currentValue.id > 0) {
                            renderTile(ctx, currentValue.id, canvasX, canvasY, 1.0);
                        } else if (currentValue.type === 'animated') {
                            renderSpecialTile(ctx, currentValue.value, canvasX, canvasY);
                        }
                    } else if (currentLayer !== 'main' && currentValue > 0) {
                        renderTile(ctx, currentValue, canvasX, canvasY, 1.0);
                    }
                }
            }
            
            // Render player spawn (0-based coordinates, Y from top to bottom)
            if (showPlayerSpawn) {
                const spawnX = mapData.playerSpawn.x * canvasTileSize; // Removed -1
                const spawnY = mapData.playerSpawn.y * canvasTileSize; // Removed -1
                
                ctx.strokeStyle = '#1abc9c';
                ctx.lineWidth = 3;
                ctx.strokeRect(spawnX + 2, spawnY + 2, canvasTileSize - 4, canvasTileSize - 4);
                
                ctx.fillStyle = '#1abc9c';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('P', spawnX + canvasTileSize / 2, spawnY + canvasTileSize / 2 + 6);
            }
            
            // Render grid
            if (showGrid) {
                ctx.strokeStyle = 'rgba(189, 195, 199, 0.5)';
                ctx.lineWidth = 1;
                
                for (let x = 0; x <= mapData.width; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * canvasTileSize, 0);
                    ctx.lineTo(x * canvasTileSize, canvas.height);
                    ctx.stroke();
                }
                
                for (let y = 0; y <= mapData.height; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * canvasTileSize);
                    ctx.lineTo(canvas.width, y * canvasTileSize);
                    ctx.stroke();
                }
            }
        }
        
        function renderTile(ctx, tileId, x, y, alpha = 1.0) {
            if (textureAtlas && tileId > 0) {
                const tileInfo = getTileFromAtlas(tileId);
                if (tileInfo) {
                    ctx.globalAlpha = alpha;
                    ctx.drawImage(
                        textureAtlas,
                        tileInfo.x, tileInfo.y, tileInfo.width, tileInfo.height,
                        x, y, canvasTileSize, canvasTileSize
                    );
                    ctx.globalAlpha = 1.0;
                    return;
                }
            }
            
            // Fallback rendering
            const hue = (tileId * 137.508) % 360;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = tileId === 0 ? '#34495e' : `hsl(${hue}, 50%, 50%)`;
            ctx.fillRect(x, y, canvasTileSize, canvasTileSize);
            
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(tileId, x + canvasTileSize / 2, y + canvasTileSize / 2 + 4);
            ctx.globalAlpha = 1.0;
        }
        
        function renderSpecialTile(ctx, value, x, y) {
            const colors = {
                'a10|4|8': '#f39c12',  // KEY
                'a11|4|8': '#9b59b6',  // BUTTON
                'a12|4|8': '#e67e22',  // DOOR
                'a14|4|8': '#27ae60'   // END
            };
            
            const symbols = {
                'a10|4|8': 'üîë',
                'a11|4|8': 'üîò',
                'a12|4|8': 'üö™',
                'a14|4|8': 'üèÅ'
            };
            
            ctx.fillStyle = colors[value] || '#95a5a6';
            ctx.fillRect(x, y, canvasTileSize, canvasTileSize);
            
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(symbols[value] || '?', x + canvasTileSize / 2, y + canvasTileSize / 2 + 6);
        }
        
        function clearLayer() {
            const layer = getCurrentLayer();
            for (let y = 0; y < mapData.height; y++) {
                for (let x = 0; x < mapData.width; x++) {
                    if (currentLayer === 'main') {
                        layer[y][x] = { type: 'tile', id: 0 };
                    } else {
                        layer[y][x] = 0;
                    }
                }
            }
            renderMap();
        }
        
        function fillLayer() {
            const layer = getCurrentLayer();
            const fillValue = selectedSpecialTile ? 
                { type: 'animated', value: selectedSpecialTile } : 
                (currentLayer === 'main' ? { type: 'tile', id: selectedTileId } : selectedTileId);
            
            for (let y = 0; y < mapData.height; y++) {
                for (let x = 0; x < mapData.width; x++) {
                    layer[y][x] = fillValue;
                }
            }
            renderMap();
        }
        
        function copyFromTemplateFile(fileContent) {
            try {
                const lines = fileContent.trim().split('\n').filter(line => line.trim() !== '');
                let lineIndex = 0;
                
                // Read header information - 4 d√≤ng theo format game
                const templateWidth = parseInt(lines[lineIndex++]);
                const templateHeight = parseInt(lines[lineIndex++]);
                const playerX = parseInt(lines[lineIndex++]);
                const playerY = parseInt(lines[lineIndex++]);
                
                // Update map settings if different
                if (templateWidth !== mapData.width || templateHeight !== mapData.height) {
                    document.getElementById('mapWidth').value = templateWidth;
                    document.getElementById('mapHeight').value = templateHeight;
                    mapData.width = templateWidth;
                    mapData.height = templateHeight;
                    setupMapCanvas();
                }
                
                // Update other settings
                document.getElementById('playerX').value = playerX;
                document.getElementById('playerY').value = playerY;
                mapData.playerSpawn.x = playerX;
                mapData.playerSpawn.y = playerY;
                
                // Initialize layers with new dimensions
                mapData.bottomLayer = Array(templateHeight).fill().map(() => Array(templateWidth).fill(0));
                mapData.mainLayer = Array(templateHeight).fill().map(() => Array(templateWidth).fill({ type: 'tile', id: 0 }));
                mapData.activeLayer = Array(templateHeight).fill().map(() => Array(templateWidth).fill(0));
                
                // Read bottom layer (background layer)
                for (let y = 0; y < templateHeight; y++) {
                    const rowData = lines[lineIndex++].replace(/,$/, '').split(',').map(x => parseInt(x.trim()));
                    for (let x = 0; x < templateWidth && x < rowData.length; x++) {
                        mapData.bottomLayer[y][x] = rowData[x];
                    }
                }
                
                // Read main layer (static tiles + special items)
                for (let y = 0; y < templateHeight; y++) {
                    const rowData = lines[lineIndex++].replace(/,$/, '').split(',').map(x => parseInt(x.trim()));
                    for (let x = 0; x < templateWidth && x < rowData.length; x++) {
                        const value = rowData[x];
                        // Convert special tile IDs back to animated tiles
                        if (value === 10) {
                            mapData.mainLayer[y][x] = { type: 'animated', value: 'a10|4|8' }; // KEY
                        } else if (value === 11) {
                            mapData.mainLayer[y][x] = { type: 'animated', value: 'a11|4|8' }; // BUTTON
                        } else if (value === 12) {
                            mapData.mainLayer[y][x] = { type: 'animated', value: 'a12|4|8' }; // DOOR
                        } else if (value === 14) {
                            mapData.mainLayer[y][x] = { type: 'animated', value: 'a14|4|8' }; // END
                        } else {
                            mapData.mainLayer[y][x] = { type: 'tile', id: value };
                        }
                    }
                }
                
                // Read active layer (moveable/interactive objects)
                for (let y = 0; y < templateHeight; y++) {
                    if (lineIndex < lines.length) {
                        const rowData = lines[lineIndex++].replace(/,$/, '').split(',').map(x => parseInt(x.trim()));
                        for (let x = 0; x < templateWidth && x < rowData.length; x++) {
                            mapData.activeLayer[y][x] = rowData[x];
                        }
                    }
                }
                
                renderMap();
                alert('Template loaded successfully! All 3 layers imported.');
                
            } catch (error) {
                console.error('Error loading template:', error);
                alert('Error loading template file. Please check the file format.');
            }
        }
        
        function copyFromTemplate() {
            // Keep the old hardcoded template as backup
            if (mapData.width === 15 && mapData.height === 13) {
                const templateBottom = [
                    [18,18,18,18,18,18,19,36,17,18,18,18,18,18,18],
                    [18,18,18,18,18,18,19,36,17,18,18,18,18,18,18],
                    [81,82,81,82,81,82,19,36,17,81,82,81,82,81,82],
                    [18,18,18,18,4,34,35,36,33,34,5,18,18,18,18],
                    [81,82,81,82,19,36,36,36,36,36,17,81,82,81,82],
                    [18,18,18,18,19,36,36,36,36,36,17,18,18,18,18],
                    [81,82,81,82,20,2,2,2,2,2,21,81,82,81,82],
                    [18,18,18,18,18,18,9,18,18,25,18,18,18,18,18],
                    [81,82,81,82,18,18,18,18,18,18,18,81,82,81,82],
                    [18,18,18,18,18,18,18,18,18,18,18,18,18,18,18],
                    [81,82,81,82,18,18,18,18,9,18,18,81,82,81,82],
                    [18,18,18,18,18,25,18,18,18,18,18,18,18,18,18],
                    [81,82,81,82,18,18,18,18,18,18,18,81,82,81,82]
                ];
                
                for (let y = 0; y < mapData.height; y++) {
                    for (let x = 0; x < mapData.width; x++) {
                        mapData.bottomLayer[y][x] = templateBottom[y][x];
                    }
                }
                
                renderMap();
                alert('Template copied to bottom layer!');
            } else {
                alert('Template only works for 15x13 maps. Please create a 15x13 map first.');
            }
        }
        
        function exportMap() {
            // Update settings from UI
            mapData.playerSpawn.x = parseInt(document.getElementById('playerX').value);
            mapData.playerSpawn.y = parseInt(document.getElementById('playerY').value);
            
            let output = '';
            
            // Header - 4 d√≤ng theo format game: width, height, playerX, playerY
            output += mapData.width + '\n';
            output += mapData.height + '\n';
            output += mapData.playerSpawn.x + '\n';
            output += mapData.playerSpawn.y + '\n';
            
            // Bottom layer (background layer)
            for (let y = 0; y < mapData.height; y++) {
                const row = mapData.bottomLayer[y];
                output += row.join(',') + '\n';
            }
            
            // Main layer (static tiles and special items)
            for (let y = 0; y < mapData.height; y++) {
                const row = mapData.mainLayer[y].map(cell => {
                    if (cell.type === 'animated') {
                        // Chuy·ªÉn ƒë·ªïi animated tiles v·ªÅ tile IDs
                        const animatedMap = {
                            'a10|4|8': 10,  // Question -> KEY
                            'a11|4|8': 11,  // Teleport -> BUTTON  
                            'a12|4|8': 12,  // Exclamation -> DOOR
                            'a14|4|8': 14   // End -> END
                        };
                        return animatedMap[cell.value] || 0;
                    } else if (cell.type === 'tile') {
                        return cell.id;
                    }
                    return 0;
                });
                output += row.join(',') + '\n';
            }
            
            // Active layer (moveable/interactive objects)
            for (let y = 0; y < mapData.height; y++) {
                const row = mapData.activeLayer[y];
                output += row.join(',') + '\n';
            }
            
            document.getElementById('exportText').value = output;
        }
        
        function copyToClipboard() {
            const exportText = document.getElementById('exportText');
            exportText.select();
            document.execCommand('copy');
            alert('Map data copied to clipboard!');
        }
        
        function downloadMap() {
            const exportText = document.getElementById('exportText').value;
            if (!exportText) {
                alert('Please generate map data first!');
                return;
            }
            
            const blob = new Blob([exportText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `map_${mapData.width}x${mapData.height}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
